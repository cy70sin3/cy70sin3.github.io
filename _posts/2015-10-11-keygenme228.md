---
layout: post
title: Keygenme228
tags:
- Crackmes
---

> This is a basic keygenme in Linux. Enjoy!  
<!--more-->

<a href="http://www.crackmes.de/users/profdraculare/keygenme228/">Binary</a>  
This was a nice simple challenge. Single user input gets stored at esp+15 and length checked ( > 0x02 ).

{% highlight text %}
804853e: e8 cd fe ff ff        call   8048410 <__isoc99_scanf@plt>
8048543: 8d 44 24 15           lea    eax,[esp+0x15]
8048547: 89 04 24              mov    DWORD PTR [esp],eax
804854a: e8 a1 fe ff ff        call   80483f0 <strlen@plt>
804854f: 89 84 24 14 01 00 00  mov    DWORD PTR [esp+0x114],eax
8048556: 83 bc 24 14 01 00 00  cmp    DWORD PTR [esp+0x114],0x2 // test > 0x02
{% endhighlight %}

Two checks are done but only one needs to pass.  

1. Increasing sequence
2. Decreasing sequence

Case 1:
{% highlight text %}
80485ad: 89 c8              mov    eax,ecx
80485af: 85 c0              test   eax,eax
80485b1: 7e 0d              jle    80485c0 <main+0xb4> a[i] <= a[i+1]
{% endhighlight %}

Case 2:
{% highlight text %}
804862c: 89 c8              mov    eax,ecx
804862e: 85 c0              test   eax,eax
8048630: 79 0d              jns    804863f <main+0x133> a[i] >= a[i+1]
{% endhighlight text %}

## Solution

{% highlight python %}
import random
import sys

def case1():
  serial = []
  for i in range(0,10):
    serial.append(random.choice((0x61,0x7a)))
  serial.sort()
  return serial

def case2():
  serial = []
  for i in range(0,10):
    serial.append(random.choice((0x61,0x7a)))
  serial.sort(reverse=True)
  return serial

choice = raw_input("Case? ")
if choice == 1:
  print case1()
else:
  print case2()
{% endhighlight %}
